module Synthesis2AMN;
create OUT:AMN from IN:Synthesis;

-- =============================================================================
-- HELPERS
-- =============================================================================
						
	helper def: counter : Integer = 0;

helper context Synthesis!Formula def: splitToAtoms(): Sequence(Synthesis!Atom) =
	if self.oclIsKindOf(Synthesis!Atom) then
		Sequence{self}
	else
		if self.oclIsTypeOf(Synthesis!Negation) then
			self.formula.splitToAtoms()
		else
			if self.oclIsTypeOf(Synthesis!Conjunction) or self.oclIsTypeOf(Synthesis!Disjunction) then
				self.formula->asSequence()->at(1).splitToAtoms()->union(self.formula->asSequence()->at(2).splitToAtoms())
			else
				if self.oclIsTypeOf(Synthesis!Implication) then
					self.antecedent.splitToAtoms()->union(self.consequent.splitToAtoms())
				else
					if self.oclIsKindOf(Synthesis!QuantifiedFormula) then 
						self.formula.splitToAtoms()
					else
						Sequence{}
					endif
				endif
			endif
		endif
	endif;
					
-- =============================================================================
-- RULES
-- =============================================================================
	
rule SynthesisModule2AMNAbstractMachine {
	from
		m : Synthesis!ModuleDef(
			m.oclIsTypeOf(Synthesis!ModuleDef)
			--false
			) 
	to
	    am : AMN!AbstractMachine (
			name <- 'Context' + m.name--,
--			sets <- avalSet, 
--			sets <- oidSet,
--			concreteConstants <- objConst,
--			concreteConstants <- selfConst,
--			concreteConstants <- m.containedTypes->collect(e | thisModule.setConstantsExtpFromADT(e)),
--			concreteConstants <- m.containedTypes->collect(e | thisModule.setConstantsExtFromADT(e)),
--			properties <- propertiesPredicate
		)--,
		
--		avalSet : AMN!Deferred (
--			name <- 'Aval'
--		),
--		oidSet : AMN!Deferred (
--			name <- 'OID'
--		),
--		
--		objConst : AMN!NamedConstant (
--			name <- 'Obj'
--		),
--		selfConst : AMN!NamedConstant (
--			name <- 'self'
--		),		
--		
--		propertiesPredicate : AMN!Conjunction (
--			sign <- '&',
--			predicate <- objProp,
--			predicate <- selfProp,
--			predicate <- equalsPredicate,
--			predicate <- m.containedTypes->collect(e | thisModule.typeConstantsForEachADT(e)),
--			predicate <- conjunction
--		),
--		conjunction : AMN!Conjunction (
--			sign <- 'thisFuckingConjunction'
--		),
--		objProp : AMN!AtomicPredicate (
--			sign <- 'Belongs',
--			expression <- leftObj,
--			expression <- rightAval
--		),
--
--		leftObj : AMN!NamedConstant (
--			name <- 'Obj'
--		),
--		rightAval : AMN!FunctionalExpression (
--			sign <- 'POW',
--			expression <- nameConstAval			
--		),
--		nameConstAval : AMN!NamedConstant (
--			name <- 'AVAL'
--		),
--		selfProp : AMN!AtomicPredicate (
--			sign <- 'Belongs',
--			expression <- leftSelf,
--			expression <- rightObjOID
--		),
--		leftSelf : AMN!NamedConstant (
--			name <- 'self'
--		),
--		rightObjOID : AMN!BinaryOperator (
--			sign <- 'TotalBijection',
--			expression <- leftTotalBijection,
--			expression <- rightTotalBijection			
--		),
--		leftTotalBijection : AMN!NamedConstant (
--			name <- 'Obj'
--		),
--		rightTotalBijection : AMN!NamedConstant (
--			name <- 'OID'
--		),
--		equalsPredicate: AMN!AtomicPredicate (
--			sign <- 'Equals',
--			expression <- intersection,
--			expression <- emptySet
--		),
--		intersection : AMN!BinaryOperator (
--			sign <- 'Intesection',
--			expression <- m.containedTypes->collect(e | thisModule.setConstantsExtpFromADT(e))	
--		),
--		emptySet : AMN!SetValue (
--			value <- emptySetExp			
--		),
--		emptySetExp : AMN!StringValue (
--			value <- 'emptyset'	
--		)
}

lazy rule setConstantsExtpFromADT {
	from
		adt : Synthesis!ADTDef(adt.oclIsTypeOf(Synthesis!ADTDef)) 
	to
		e1 : AMN!NamedConstant (
			name <- 'extp_' + adt.name
		)
}

lazy rule setConstantsExtFromADT {
	from
		adt : Synthesis!ADTDef(adt.oclIsTypeOf(Synthesis!ADTDef)) 
	to
		e2 : AMN!NamedConstant (
			name <- 'ext_' + adt.name
		)
 }

lazy rule typeConstantsForEachADT {
	from
		adt : Synthesis!ADTDef(adt.oclIsTypeOf(Synthesis!ADTDef)) 
	to
		conjunction : AMN!Conjunction (
			sign <- '&',
			predicate <- leftPred,
			predicate <- middlePred,
			predicate <- rightPred
		),
		leftPred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftLeft,
			expression <- rightLeft
		),
		leftLeft : AMN!NamedConstant (
			name <- 'ext_' + adt.name
		),
		rightLeft : AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- objExpLeft
		),
		objExpLeft : AMN!NamedConstant (
			name <- 'Obj'
		),		
		middlePred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftMiddle,
			expression <- rightMiddle
		),
		leftMiddle : AMN!NamedConstant (
			name <- 'extp_' + adt.name
		),
		rightMiddle : AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- objExpMiddle
		),
		objExpMiddle : AMN!NamedConstant (
			name <- 'Obj'
		),
		rightPred : AMN!AtomicPredicate (
			sign <- 'Inclusion',
			expression <- leftRight,
			expression <- rightRight
		),
		leftRight : AMN!NamedConstant (
			name <- 'extp_' + adt.name
		),
		rightRight : AMN!NamedConstant (
			name <- 'ext_' + adt.name
		)
 }

-- Построение конъюнкции тип-подтип и запись ее в контекстную машину модуля
--rule genStrictInclusionFromSubtype(adt : Synthesis!ADTDef, subTypeName : String) {
--	to
--		strictInclusionSubtypeRelation : AMN!AtomicPredicate (
--			sign <- 'Inclusion SUBTYPE',
--			expression <- Sequence{leftExp,rightExp}
--		),
--		leftExp : AMN!NamedConstant (
--			name <- 'ext_' + subTypeName
--		),
--		rightExp : AMN!NamedConstant (
--			name <- 'ext_' + adt.name
--		)
--	do {
--		thisModule.resolveTemp(Synthesis!ModuleDef.allInstances()->any(m|m.oclIsTypeOf(Synthesis!ModuleDef)),'conjunction').predicate<-strictInclusionSubtypeRelation;
--	} 
--}

rule SynthesisADT2AMNAbstractMachine {
	from
		adt : Synthesis!ADTDef(
			adt.oclIsTypeOf(Synthesis!ADTDef)
			--false
		)  
	to
		am : AMN!AbstractMachine (
			name <- adt.name,
			--concreteVariables <- adt.attributes->collect(e | thisModule.attributesToVariables(e)),
			--operations <- adt.attributes->collect(e | thisModule.attributesToOperations(e)),
			--operations <- adt.attributes->select(t | t.type.oclIsTypeOf(Synthesis!FunctionDef))->collect(e | thisModule.functionalattributesToOperations(e)),
			--initialization <- initSubt,
			--invariant <- predicate,
			sees <- thisModule.resolveTemp(Synthesis!ModuleDef.allInstances()->any(m|m.oclIsTypeOf(Synthesis!ModuleDef)), 'am')
			--extendsClause <- adt.supertypes,
		)--,
--		predicate : AMN!Conjunction (
--			predicate <- adt.attributes->collect(e | thisModule.attributesToInvariants(e))
--		),
--		initSubt : AMN!Simultaneous (
--			substitution <- adt.attributes->collect(e | thisModule.attributesToInitialization(e))
--		)
	do {
-- Вызов построения конъюнкции для отношения тип-подтип
--		if (adt.subtypes->notEmpty()) {
--			for (e in adt.subtypes) {			
--					thisModule.genStrictInclusionFromSubtype(adt,e.name);
--			}
--		}

-- Инклюдится машина, определяющая супертип
		if (adt.supertypes->notEmpty()) {
			for (e in adt.supertypes) {			
					am.includes <- thisModule.resolveTemp(Synthesis!ADTDef.allInstances()->any(m|m.name = e.name), 'am');
			}
		}
	}
}

lazy rule attributesToVariables {
	from
		at : Synthesis!AttributeDef(
			at.oclIsTypeOf(Synthesis!AttributeDef)
			) 
	to
		el : AMN!Variable (
			name <- at.name
 		)
}

lazy rule attributesToInvariants {
	from
		at : Synthesis!AttributeDef(
			at.oclIsTypeOf(Synthesis!AttributeDef)
			) 
	to
		attrPred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftExp,
			expression <- rightExp
		),
		leftExp : AMN!NamedConstant (
			name <- at.name
		),
		rightExp : AMN!BinaryOperator (
			sign <- 'TotalFunction',
			expression <- leftTotalFunction,
			expression <- rightTotalFunction			
		),
		leftTotalFunction : AMN!NamedConstant (
			name <- 'ext_' + at.attributeOf.name			
		),
		rightTotalFunction : AMN!NamedConstant (			
		)
	do {
		if (at.type.oclIsTypeOf(Synthesis!StringDef)) {
			rightTotalFunction.name <- 'String';
		}
		if (at.type.oclIsTypeOf(Synthesis!IntegerDef)) {
		 	rightTotalFunction.name <- 'NAT';
		}
--		if (at.type.oclIsTypeOf(Synthesis!SetDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
--		if (at.type.oclIsTypeOf(Synthesis!EnumDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
	}
}

lazy rule attributesToOperations {
	from
		at : Synthesis!AttributeDef(
			at.oclIsTypeOf(Synthesis!AttributeDef)
			) 
	to
		operation : AMN!Operation (
			name <- 'set' + at.name,
			inputParams <- inpVar,
			substitution <- subst
		),
		inpVar : AMN!Variable (
			name <- 'sav'
		),
		subst : AMN!Precondition (
			pre <- predicate,
			thenPart <- substitution
		),
		predicate : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftExp,
			expression <- rightExp
		),
		leftExp : AMN!NamedConstant (
			name <- 'sav'
		),
		rightExp : AMN!BinaryOperator (
			sign <- 'PartialFunction',
			expression <- leftTotalFunction,
			expression <- rightTotalFunction			
		),
		leftTotalFunction : AMN!NamedConstant (
			name <- 'ext_' + at.attributeOf.name			
		),
		rightTotalFunction : AMN!NamedConstant (			
		),
		substitution : AMN!BecomesEqual (
			leftExpression <- leftExpBecomes,
			rightExpression <- rightExpBecomes
		),
		leftExpBecomes : AMN!NamedConstant (
			name <- at.name			
		),
		rightExpBecomes : AMN!BinaryOperator (
			sign <- 'Overwrite',
			expression <- leftOverwrite,
			expression <- rightOverwrite
		),
		leftOverwrite : AMN!NamedConstant (
			name <- at.name			
		),
		rightOverwrite : AMN!NamedConstant (
			name <- 'sav'			
		)
	do {
		if (at.type.oclIsTypeOf(Synthesis!StringDef)) {
			rightTotalFunction.name <- 'String';
		}
		if (at.type.oclIsTypeOf(Synthesis!IntegerDef)) {
		 	rightTotalFunction.name <- 'NAT';
		}
--		if (at.type.oclIsTypeOf(Synthesis!SetDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
--		if (at.type.oclIsTypeOf(Synthesis!EnumDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
	}		
}

lazy rule attributesToInitialization {
	from
		at : Synthesis!AttributeDef(
			at.oclIsTypeOf(Synthesis!AttributeDef)
			) 
	to
		substitution : AMN!Any (
			any <- setVarName,
			where <- pred,
			thenPart <- subst
		),
		setVarName : AMN!Variable (
			name <- 'a' + at.name
		),
		pred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftExp,
			expression <- rightExp
		),
		leftExp : AMN!NamedConstant (
			name <- 'a' + at.name
		),
		rightExp : AMN!BinaryOperator (
			sign <- 'TotalFunction',
			expression <- leftTotalFunction,
			expression <- rightTotalFunction			
		),
		leftTotalFunction : AMN!NamedConstant (
			name <- 'ext_' + at.attributeOf.name			
		),
		rightTotalFunction : AMN!NamedConstant (			
		),
		subst : AMN!BinaryOperator (
			sign <- 'Overwrite',
			expression <- leftOverwrite,
			expression <- rightOverwrite
		),
		leftOverwrite : AMN!NamedConstant (
			name <- at.name			
		),
		rightOverwrite : AMN!NamedConstant (
			name <- 'a' + at.name			
		)
	do {
		if (at.type.oclIsTypeOf(Synthesis!StringDef)) {
			rightTotalFunction.name <- 'String';
		}
		if (at.type.oclIsTypeOf(Synthesis!IntegerDef)) {
		 	rightTotalFunction.name <- 'NAT';
		}
--		if (at.type.oclIsTypeOf(Synthesis!SetDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
--		if (at.type.oclIsTypeOf(Synthesis!EnumDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
	}		
}

rule functionalattributesToOperations {	
	from
		at : Synthesis!AttributeDef(
			at.oclIsTypeOf(Synthesis!AttributeDef) and at.type.oclIsTypeOf(Synthesis!FunctionDef)
			) 
	to
		operation : AMN!Operation (
			name <- 'OPERATION ' + at.name,
			inputParams <- objParam,
			substitution <- subst
		),
		objParam : AMN!Variable (
			name <- 'o'			
		),
		subst : AMN!Precondition (
			pre <- precondPredicate,
			thenPart <- thenSubstAny 
		),
		precondPredicate : AMN!Conjunction ( 
			predicate <- objPred
		),
		objPred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftAtomic,
			expression <- rightAtomic
		),
		leftAtomic : AMN!Variable (
			name <- 'o'
		),
		rightAtomic : AMN!NamedConstant (
			name <- 'ext' + at.attributeOf.name
		),
		thenSubstAny : AMN!Any (
			--any <-,
			--where <- ,
--			--thenPart <- 
		)
	do {
		for ( e in at.type.parameters ) {
			thisModule.generateParameters(e, at);
		}
		thisModule.resolveTemp(Synthesis!ADTDef.allInstances()->any(m | m.name = at.attributeOf.name),'am').operations<-operation;
	}
}

rule generateParameters ( param : Synthesis!ParameterDef, attr : Synthesis!AttributeDef ) {
	to 
		var : AMN!Variable (
			name <- param.name			
		),
		varPred : AMN!AtomicPredicate (
			sign <- 'Belongs to Datatype In operation',
			expression <- var,
			expression <- rightAtomic
		),
		rightAtomic : AMN!NamedConstant (
			name <- param.type.name
		)
	do {
		if ( param.parameterKind = 'input' ) {
			thisModule.resolveTemp(Synthesis!AttributeDef.allInstances()->
									any(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
												then if m.name = attr.name 
														then true
														else false
														endif
												else false
											endif),'operation').inputParams<-var;
		}
		else {
			if ( param.parameterKind = 'output' ) {
				thisModule.resolveTemp(Synthesis!AttributeDef.allInstances()->
									any(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
												then if m.name = attr.name 
														then true
														else false
														endif
												else false
											endif),'operation').outputParams<-var;
			}
		}
		thisModule.resolveTemp(Synthesis!AttributeDef.allInstances()->
									any(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
												then if m.name = attr.name 
														then true
														else false
														endif
												else false
											endif),'precondPredicate').predicate<-varPred;
	}
}

-- =============================================================================
-- Построение трансформации формул СИНТЕЗа в предикаты AMN
-- =============================================================================

rule conjunctionToAMNConjunciton {
	from 
		conjSynth : Synthesis!Conjunction(conjSynth.oclIsTypeOf(Synthesis!Conjunction))
	to
		conjAMN : AMN!Conjunction (
			predicate <- conjSynth.formula
		)
}

rule disjunctionToAMNDisjunction {
	from 
		disjSynth : Synthesis!Disjunction(disjSynth.oclIsTypeOf(Synthesis!Disjunction))
	to
		disjAMN : AMN!Disjunction (
			predicate <- disjSynth.formula
		)
}

rule negationToAMNNegation {
	from 
		negSynth : Synthesis!Negation(negSynth.oclIsTypeOf(Synthesis!Negation))
	to
		negAMN : AMN!Negation (
			predicate <- negSynth.formula
		)
}

rule implicationToAMNImplication {
	from 
		implSynth : Synthesis!Implication(implSynth.oclIsTypeOf(Synthesis!Implication))
	to
		implAMN : AMN!Implication (
			consequent <- implSynth.consequent,
			antedecent <- implSynth.antedecent
		)
}

rule quantifiedToAMNQuantified {
	from 
		quanSynth : Synthesis!QuantifiedFormula(quanSynth.oclIsTypeOf(Synthesis!QuantifiedFormula))
	to
		quanAMN : AMN!QuantifiedFormula (
			predicate <- Sequence {typedVarConj,quanSynth.formula},
			variables <- quanSynth.variables
		),
		typedVarConj : AMN!Conjunction (
			predicate <- quanSynth.variables->collect(e | thisModule.quantVarsToTypedVarPredicate(e))
		)		
}

lazy rule quantVarsToTypedVarPredicate {
	from 
		synthVar : Synthesis!Variable(synthVar.oclIsTypeOf(Synthesis!Variable))
	to
		atomConj : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftAtomic,
			expression <- rightAtomic
		),
		leftAtomic : AMN!Variable (
			name <- synthVar.name
		),
		rightAtomic : AMN!NamedConstant (
			name <- 'ext_' + synthVar.typeOfValue
		)
}

rule getFunciton2AMNExpression {
	from 
		synthGetFunction : Synthesis!GetFunction(synthGetFunction.oclIsTypeOf(Synthesis!GetFunction))
	to 
		expression : AMN!BinaryOperator (
			sign <- '()',
			expression <- Sequence {varAttr,varObjType}
		),
		varAttr : AMN!Variable (
			name <- synthGetFunction.attribute.name
		),
		varObjType : AMN!Variable (
		)
	do {
		if ( synthGetFunction.name.startsWith('this') ) {
			varObjType.name <- 'o';
		}
	}
}

rule setFunction2AMNExpression {
	from
		synthSetFunction : Synthesis!SetFunction(synthSetFunction.oclIsTypeOf(Synthesis!SetFunction))
	to 
		var : AMN!Variable (
			name <- 'v' + thisModule.counter
		)
	do {
		thisModule.counter <- thisModule.counter + 1;
		for ( funcAttr in Synthesis!AttributeDef.allInstances()->select(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
																	then true
																	else false
																	endif)) {
			for ( atom in funcAttr.type.predicativeSpec.splitToAtoms()) {
				for ( term in atom.terms ) {
					if ( term.oclIsTypeOf(Synthesis!SetFunction) ) {
						if ( term.name = synthSetFunction.name ) {
							thisModule.resolveTemp(Synthesis!AttributeDef.allInstances()->
									any(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
												then if m.name = funcAttr.name 
														then true
														else false
														endif
												else false
											endif),'thenSubstAny').any<-var;
						}
					}
				}
			}
		}
	}
}

rule atomToAMNAtomicPredicate {
	from 
		atomSynth : Synthesis!Atom(atomSynth.oclIsTypeOf(Synthesis!Atom))
	to
		atomicAMN : AMN!AtomicPredicate (
			sign <- atomSynth.symbol,
			expression <- atomSynth.terms
		)
}

rule termToAMNStringValue {
	from
		term : Synthesis!StringValueDef(term.oclIsTypeOf(Synthesis!StringValueDef))
	to
		stringVal : AMN!StringValue (
			value <- term.value 
		)
}

rule termToAMNBooleanValue {
	from
		term : Synthesis!BooleanValueDef(term.oclIsTypeOf(Synthesis!BooleanValueDef))
	to
		boolVal : AMN!BooleanValue (
			value <- term.value 
		)
}

rule termToAMNIntegerValue {
	from
		term : Synthesis!IntegerValueDef(term.oclIsTypeOf(Synthesis!IntegerValueDef))
	to
		integerVal : AMN!IntegerValue (
			value <- term.value 
		)
}

rule termToAMNSetValue {
	from
		term : Synthesis!SetValueDef(term.oclIsTypeOf(Synthesis!SetValueDef))
	to
		integerVal : AMN!SetValue (
			values <- term.values 
		)
}

rule builtInPredicate2AtomicPredicate {
	from 
		builtIn : Synthesis!BuiltInPredicate(builtIn.oclIsTypeOf(Synthesis!BuiltInPredicate))
	to
		atomPred : AMN!AtomicPredicate (
			sign <- builtIn.symbol,
			expression <- builtIn.terms
		)
}

rule builtInFunction2FunctionalExpression {
	from 
		builtIn : Synthesis!BuiltInFunction(builtIn.oclIsTypeOf(Synthesis!BuiltInFunction))
	to
		funcExp : AMN!FunctionalExpression (
			sign <- builtIn.name,
			expression <- builtIn.terms
		)
}


