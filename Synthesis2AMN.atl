module Synthesis2AMN;
create OUT:AMN from IN:Synthesis;

-- =============================================================================
-- HELPERS
-- =============================================================================
						
	helper def: counter : Integer = 0;

helper context Synthesis!Formula def: splitToAtoms(): Sequence(Synthesis!Atom) =
	if self.oclIsKindOf(Synthesis!Atom) then
		Sequence{self}
	else
		if self.oclIsTypeOf(Synthesis!Negation) then
			self.formula.splitToAtoms()
		else
			if self.oclIsTypeOf(Synthesis!Conjunction) or self.oclIsTypeOf(Synthesis!Disjunction) then
				self.formula->asSequence()->at(1).splitToAtoms()->union(self.formula->asSequence()->at(2).splitToAtoms())
			else
				if self.oclIsTypeOf(Synthesis!Implication) then
					self.antecedent.splitToAtoms()->union(self.consequent.splitToAtoms())
				else
					if self.oclIsKindOf(Synthesis!QuantifiedFormula) then 
						self.formula.splitToAtoms()
					else
						Sequence{}
					endif
				endif
			endif
		endif
	endif;
					
helper context Synthesis!AttributeDef def: isNotFunctional(): Boolean =					
	if self.oclIsTypeOf(Synthesis!AttributeDef)
		then if not self.type.oclIsTypeOf(Synthesis!FunctionDef)
				then true
				else false
				endif
		else false
	endif;

helper context Synthesis!AttributeDef def: isFunctional(): Boolean =
	if self.oclIsTypeOf(Synthesis!AttributeDef)
		then if self.type.oclIsTypeOf(Synthesis!FunctionDef)
				then true
				else false
				endif
		else false
	endif;

-- =============================================================================
-- RULES
-- =============================================================================
	
rule SynthesisModule2AMNAbstractMachine {
	from
		m : Synthesis!ModuleDef(m.oclIsTypeOf(Synthesis!ModuleDef)) 
	to
	    am : AMN!AbstractMachine (
			name              <- 'Context' + m.name,
			sets              <- Sequence {avalSet, oidSet}, 
			abstractConstants <- Sequence {	objConst,selfConst},
			properties <- propertiesPredicate
		),		
		avalSet : AMN!Deferred (
			name <- 'AVAL'
		),
		oidSet : AMN!Deferred (
			name <- 'OID'
		),		
		objConst : AMN!NamedConstant (
			name <- 'Obj'
		),
		selfConst : AMN!NamedConstant (
			name <- 'self'
		),		
		propertiesPredicate : AMN!Conjunction (
			predicate <- Sequence { objProp, selfProp, equalsPredicate}
		),
		objProp : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- objConst,
			expression <- rightAval
		),
		rightAval : AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- avalSet			
		),
		selfProp : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- selfConst,
			expression <- rightObjOID
		),
		rightObjOID : AMN!BinaryOperator (
			sign <- 'TotalBijection',
			expression <- objConst,
			expression <- oidSet			
		),
		equalsPredicate: AMN!AtomicPredicate (
			sign <- 'Equals',
			expression <- intersection,
			expression <- emptySet
		),
		intersection : AMN!BinaryOperator (
			sign <- 'Intesection'	
		),
		emptySet : AMN!SetValue ()
}

rule abstractDataType2ContextMachineSectionsANDAbstractMachineForADT {
	from
		adt : Synthesis!ADTDef(adt.oclIsTypeOf(Synthesis!ADTDef))
	to 
		extp : AMN!NamedConstant (
			name <- 'extp_' + adt.name
		),
		ext : AMN!NamedConstant (
			name <- 'ext_' + adt.name
		),
		conjunction : AMN!Conjunction (
			predicate <- leftPred,
			predicate <- middlePred,
			predicate <- rightPred
		),
		leftPred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- ext,
			expression <- rightLeft
		),
		rightLeft : AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- thisModule.resolveTemp(adt.typeInModule,'objConst')
		),		
		middlePred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- extp,
			expression <- rightMiddle
		),
		rightMiddle : AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- thisModule.resolveTemp(adt.typeInModule,'objConst')
		),
		rightPred : AMN!AtomicPredicate (
			sign <- 'Inclusion',
			expression <- extp,
			expression <- ext
		),
		am : AMN!AbstractMachine (
			name <- adt.name,
			initialization <- initSubt,
			invariant <- predicate,
			sees <- thisModule.resolveTemp(adt.typeInModule, 'am')
		),
		predicate : AMN!Conjunction (),
		initSubt : AMN!Simultaneous ()
	do {
		thisModule.resolveTemp(adt.typeInModule,'am').abstractConstants<-Sequence {extp, ext};
		thisModule.resolveTemp(adt.typeInModule,'intersection').expression<-Sequence {extp, ext};
		thisModule.resolveTemp(adt.typeInModule,'propertiesPredicate').predicate<-conjunction;
-- Вызов построения конъюнкции для отношения тип-подтип
		if (adt.subtypes->notEmpty()) {
			for (subtype in adt.subtypes) {			
					thisModule.genStrictInclusionFromSubtype(adt,subtype);
			}
		}
-- Экстендится машина, определяющая супертип
		if (adt.supertypes->notEmpty()) {
			for (e in adt.supertypes) {			
					am.extendsClause <- thisModule.resolveTemp(e, 'am');
			}
		}
	}
}

-- Построение конъюнкции тип-подтип и запись ее в контекстную машину модуля
rule genStrictInclusionFromSubtype(adt : Synthesis!ADTDef, subType : Synthesis!ADTDef) {
	to
		strictInclusionSubtypeRelation : AMN!AtomicPredicate (
			sign <- 'Inclusion SUBTYPE',
			expression <- Sequence{
									thisModule.resolveTemp(subType,'ext'),
									thisModule.resolveTemp(adt,    'ext')
								  }
		)
	do {
		thisModule.resolveTemp(adt.typeInModule,'propertiesPredicate').predicate<-strictInclusionSubtypeRelation;
	} 
}

rule attribute2ATDMachineSections {
	from
		at : Synthesis!AttributeDef(
			-- at.isNotFunctional()
			false	
		) 
	to
		totalFunction : AMN!BinaryOperator (
			sign <- 'TotalFunction',
			expression <- thisModule.resolveTemp(at.attributeOf, 'ext')			
		),
		inpVar : AMN!Variable (
			name <- 'sav'
		),	
--- Переменная
		attrVar : AMN!Variable (
			name <- at.name
 		),
--- Инвариант
		attrPred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- attrVar,
			expression <- totalFunction
		),
--- Операция
		operation : AMN!Operation (
			name <- 'set_' + at.name,
			inputParams <- inpVar,
			substitution <- subst
		),
		subst : AMN!Precondition (
			pre <- predicate,
			thenPart <- substitution
		),
		predicate : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- inpVar,
			expression <- rightExpPartial
		),
		rightExpPartial : AMN!BinaryOperator (
			sign <- 'PartialFunction',
			expression <- thisModule.resolveTemp(at.attributeOf, 'ext')			
		),		
		substitution : AMN!BecomesEqual (
			leftExpression <- attrVar,
			rightExpression <- rightExpBecomes
		),
		rightExpBecomes : AMN!BinaryOperator (
			sign <- 'Overwrite',
			expression <- attrVar,
			expression <- inpVar
		),
----- Инициализация
		substitutionInit : AMN!Any (
			any <- setVarName,
			where <- pred,
			thenPart <- substBecomesEqual
		),
		setVarName : AMN!Variable (
			name <- 'a' + at.name
		),
		pred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- setVarName,
			expression <- totalFunction
		),
		substBecomesEqual : AMN!BecomesEqual (
			leftExpression <- attrVar,
			rightExpression <- setVarName
		)
	do {
		if (at.type.oclIsTypeOf(Synthesis!StringDef)) {
			thisModule.attributeTypeStringExp(at, 'STRING');
			thisModule.seesPredefinedMachine(at,'String_TYPE');
		}
		if (at.type.oclIsTypeOf(Synthesis!IntegerDef)) {
		 	thisModule.attributeTypeStringExp(at, 'NAT');
		}
		if (at.type.oclIsTypeOf(Synthesis!SetDef)) {			  
			thisModule.attributeTypeSetDef(at);
		}
		thisModule.resolveTemp(at.attributeOf, 'am').abstractVariables <- attrVar;
		thisModule.resolveTemp(at.attributeOf, 'am').operations  <- operation;
		thisModule.resolveTemp(at.attributeOf, 'initSubt').substitution  <- substitutionInit;
		thisModule.resolveTemp(at.attributeOf, 'predicate').predicate  <- attrPred;
	}
}

rule attributeTypeStringExp(attr : Synthesis!AttributeDef, stringVal : String) {
	to
		funcExp : AMN!StringValue (
			value <- stringVal
		)
	do {
		thisModule.resolveTemp(attr, 'totalFunction').expression <- funcExp;
		thisModule.resolveTemp(attr, 'rightExpPartial').expression <- funcExp;
	}
}

rule attributeTypeSetDef(attr : Synthesis!AttributeDef) {
	to
		funcExp : AMN!FunctionalExpression (
			sign <- 'POW'
		)
	do {
		funcExp.expression <- thisModule.resolveTemp(attr.type.ofType, 'ext');
		thisModule.resolveTemp(attr, 'totalFunction').expression <- funcExp;
		thisModule.resolveTemp(attr, 'rightExpPartial').expression <- funcExp;
	}
}

rule seesPredefinedMachine ( attr : Synthesis!AttributeDef,amName : String) {
	to
		abstrMachine : AMN!AbstractMachine (
			name <- amName
		)
	do {
		thisModule.resolveTemp(attr.attributeOf, 'am').sees <- abstrMachine;
	}
}

rule functionalattributesToOperations {	
	from
		at : Synthesis!AttributeDef(at.isFunctional())
	to
		operation : AMN!Operation (
			name <- 'OPERATION ' + at.name,
			inputParams <- objParam,
			substitution <- subst
		),
		objParam : AMN!Variable (
			name <- 'av'			
		),
		subst : AMN!Precondition (
			pre <- precondPredicate,
			thenPart <- thenSubstAny 
		),
		precondPredicate : AMN!Conjunction ( 
			predicate <- objPred
		),
		objPred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- thisModule.resolveTemp(at.attributeOf, 'ext'),
			expression <- objParam
		),
		thenSubstAny : AMN!Any (
			where <- whereConj,
			thenPart <- sequenceSubstitution
		),
		whereConj : AMN!Conjunction (
			predicate <- at.type.predicativeSpec
		),
		sequenceSubstitution : AMN!SequenceSubst (
		)
	do {
		for ( e in at.type.parameters ) {
			if ( e.type.oclIsTypeOf(Synthesis!ADTDef) ) {
				thisModule.generateParameters(e, at);
			}
		}
		thisModule.resolveTemp(at.attributeOf,'am').operations<-operation;
	}
}

rule generateParameters ( param : Synthesis!ParameterDef, attr : Synthesis!AttributeDef ) {
	to 
		var : AMN!Variable (
			name <- param.name			
		),		
		varPred : AMN!AtomicPredicate (
			sign <- 'Belongs to Datatype In operation',
			expression <- var,
			expression <- thisModule.resolveTemp(param.type, 'ext')
		)
	do {
		if ( param.parameterKind = 'input' ) {
			thisModule.resolveTemp(attr,'operation').inputParams<-var;
		}
		else {
			if ( param.parameterKind = 'output' ) {
				thisModule.resolveTemp(attr,'operation').outputParams<-var;
				thisModule.generateAdditionalParam(param,attr);
			}
		}
		thisModule.resolveTemp(attr,'precondPredicate').predicate<-varPred;
	}
}

rule generateAdditionalParam ( param : Synthesis!ParameterDef, attr : Synthesis!AttributeDef ) {
	to
		varAny : AMN!Variable (
			name <- 'v' + thisModule.counter
		),		
		varPred : AMN!AtomicPredicate (
			sign <- 'Belongs to Datatype In operation',
			expression <- varAny,
			expression <- thisModule.resolveTemp(param.type, 'ext')
		)
	do {				
		thisModule.resolveTemp(attr,'thenSubstAny').any<-varAny;
		thisModule.resolveTemp(attr,'whereConj').predicate<-varPred;
		thisModule.counter <- thisModule.counter + 1;
	}
}


-- =============================================================================
-- Построение трансформации формул СИНТЕЗа в предикаты AMN
-- =============================================================================

rule formula2predicate {
	from
		synthFormula : Synthesis!Formula(synthFormula.oclIsTypeOf(Synthesis!Formula))
	to 
		amnPredicate : AMN!Predicate ()
	do {
		
	}
}
	
rule conjunctionToAMNConjunciton {
	from 
		conjSynth : Synthesis!Conjunction(conjSynth.oclIsTypeOf(Synthesis!Conjunction))
	to
		conjAMN : AMN!Conjunction (
			predicate <- conjSynth.formula
		)
}

rule disjunctionToAMNDisjunction {
	from 
		disjSynth : Synthesis!Disjunction(disjSynth.oclIsTypeOf(Synthesis!Disjunction))
	to
		disjAMN : AMN!Disjunction (
			predicate <- disjSynth.formula
		)
}

rule negationToAMNNegation {
	from 
		negSynth : Synthesis!Negation(negSynth.oclIsTypeOf(Synthesis!Negation))
	to
		negAMN : AMN!Negation (
			predicate <- negSynth.formula
		)
}

rule implicationToAMNImplication {
	from 
		implSynth : Synthesis!Implication(implSynth.oclIsTypeOf(Synthesis!Implication))
	to
		implAMN : AMN!Implication (
			consequent <- implSynth.consequent,
			antedecent <- implSynth.antedecent
		)
}

rule universllyQuantifiedToAMNUniversallyQuantified {
	from 
		quanSynth : Synthesis!UniversallyQuantifiedFormula(quanSynth.oclIsTypeOf(Synthesis!UniversallyQuantifiedFormula))
	to
		quanAMN : AMN!UniversallyQuantifiedFormula (
			predicate <- Sequence {typedVarConj,quanSynth.formula},
			variables <- quanSynth.variables
		),
		typedVarConj : AMN!Conjunction (
			predicate <- quanSynth.variables->collect(e | thisModule.quantVarsToTypedVarPredicate(e))
		)		
}

lazy rule quantVarsToTypedVarPredicate {
	from 
		synthVar : Synthesis!Variable(synthVar.oclIsTypeOf(Synthesis!Variable))
	to
		atomConj : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftAtomic,
			expression <- rightAtomic
		),
		leftAtomic : AMN!Variable (
			name <- synthVar.name
		),
		rightAtomic : AMN!NamedConstant (
			name <- 'ext_' + synthVar.typeOfValue
		)
}

rule getFunciton2AMNExpression {
	from 
		synthGetFunction : Synthesis!GetFunction(synthGetFunction.oclIsTypeOf(Synthesis!GetFunction))
	to 
		expression : AMN!BinaryOperator (
			sign <- 'GetFunc',
			expression <- Sequence {varAttr,varObjType}
		),
		varAttr : AMN!Variable (
			name <- synthGetFunction.attribute.name
		),
		varObjType : AMN!Variable (
		)
	do {
		if ( synthGetFunction.name.startsWith('this') ) {
			varObjType.name <- 'av';
		}
		for ( funcAttr in Synthesis!AttributeDef.allInstances()->select(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
																	then true
																	else false
																	endif)) {
			for ( atom in funcAttr.type.predicativeSpec.splitToAtoms()) {
				for ( term in atom.terms ) {
					if ( term.oclIsTypeOf(Synthesis!GetFunction) ) {
						if ( term.name = synthGetFunction.name ) {						
							if ( funcAttr.attributeOf <> synthGetFunction.attribute.attributeOf ) {
								if ( not thisModule.resolveTemp(funcAttr.attributeOf, 'am').sees->
											exists(m|m.name = thisModule.resolveTemp(synthGetFunction.attribute.attributeOf, 'am').name) ) {
								thisModule.resolveTemp(funcAttr.attributeOf, 'am').sees <-
								thisModule.resolveTemp(synthGetFunction.attribute.attributeOf, 'am');
								}
							}
						}
					}
				}
			}
		}
	}
}

rule setFunction2AMNExpression {
	from
		synthSetFunction : Synthesis!SetFunction(synthSetFunction.oclIsTypeOf(Synthesis!SetFunction))
	to 
		var : AMN!Variable (
			name <- 'v' + thisModule.counter
		),
		varParam : AMN!Variable (
			name <- synthSetFunction.name.split('\\.')->first()
		),
		varSubstBecomesEqual : AMN!BecomesEqual (
			leftExpression <- leftExpBecomes,
			rightExpression <- var
		),
		leftExpBecomes : AMN!BinaryOperator (
			sign <- '()SetFunc',
			expression <- Sequence {varAttr,varObjType}
		),
		varAttr : AMN!Variable (
			name <- synthSetFunction.attribute.name			
		),
		varObjType : AMN!Variable (
			name <- 'o'
		),
		setExternalVar : AMN!Call (
			operationName <- 'set_' + synthSetFunction.attribute.name, 
			actualParam   <- actualParamExp
		),
		actualParamExp : AMN!BinaryOperator (
			sign <- 'binaryCorrespondence',
			expression <- Sequence {varParam,var}			
		)
	do {
		thisModule.counter <- thisModule.counter + 1;
		for ( funcAttr in Synthesis!AttributeDef.allInstances()->select(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
																	then true
																	else false
																	endif)) {
			for ( atom in funcAttr.type.predicativeSpec.splitToAtoms()) {
				for ( term in atom.terms ) {
					if ( term.oclIsTypeOf(Synthesis!SetFunction) ) {
						if ( term.name = synthSetFunction.name ) {
							thisModule.resolveTemp(Synthesis!AttributeDef.allInstances()->
									any(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
												then if m.name = funcAttr.name 
														then true
														else false
														endif
												else false
											endif),'thenSubstAny').any<-var;
							if ( funcAttr.attributeOf = synthSetFunction.attribute.attributeOf ) {
								thisModule.resolveTemp(Synthesis!AttributeDef.allInstances()->
										any(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
													then if m.name = funcAttr.name 
															then true
															else false
															endif
													else false
												endif),'sequenceSubstitution').substitution<-varSubstBecomesEqual;
							}
							else {
								thisModule.resolveTemp(Synthesis!AttributeDef.allInstances()->
										any(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
													then if m.name = funcAttr.name 
															then true
															else false
															endif
													else false
												endif),'sequenceSubstitution').substitution<-setExternalVar;
								if ( not thisModule.resolveTemp(funcAttr.attributeOf, 'am').includes->
											exists(m|m.name = thisModule.resolveTemp(synthSetFunction.attribute.attributeOf, 'am').name) ) {
								thisModule.resolveTemp(funcAttr.attributeOf, 'am').includes <-
								thisModule.resolveTemp(synthSetFunction.attribute.attributeOf, 'am');
								}
							}
						}
					}
				}
			}
		}
	}
}

rule atomToAMNAtomicPredicate {
	from 
		atomSynth : Synthesis!Atom(atomSynth.oclIsTypeOf(Synthesis!Atom))
	to
		atomicAMN : AMN!AtomicPredicate (
			sign <- atomSynth.symbol,
			expression <- atomSynth.terms
		)
}

rule termToAMNStringValue {
	from
		term : Synthesis!StringValueDef(term.oclIsTypeOf(Synthesis!StringValueDef))
	to
		stringVal : AMN!StringValue (
			value <- term.value 
		)
}

rule termToAMNBooleanValue {
	from
		term : Synthesis!BooleanValueDef(term.oclIsTypeOf(Synthesis!BooleanValueDef))
	to
		boolVal : AMN!BooleanValue (
			value <- term.value 
		)
}

rule termToAMNIntegerValue {
	from
		term : Synthesis!IntegerValueDef(term.oclIsTypeOf(Synthesis!IntegerValueDef))
	to
		integerVal : AMN!IntegerValue (
			value <- term.value 
		)
}

rule termToAMNSetValue {
	from
		term : Synthesis!SetValueDef(term.oclIsTypeOf(Synthesis!SetValueDef))
	to
		integerVal : AMN!SetValue (
			values <- term.values 
		)
}

rule builtInPredicate2AtomicPredicate {
	from 
		builtIn : Synthesis!BuiltInPredicate(builtIn.oclIsTypeOf(Synthesis!BuiltInPredicate))
	to
		atomPred : AMN!AtomicPredicate (
			sign <- builtIn.symbol,
			expression <- builtIn.terms
		)
}

rule builtInFunction2FunctionalExpression {
	from 
		builtIn : Synthesis!BuiltInFunction(builtIn.oclIsTypeOf(Synthesis!BuiltInFunction))
	to
		funcExp : AMN!FunctionalExpression (
			sign <- builtIn.name,
			expression <- builtIn.terms
		)
}

rule arithmeticPredicate2AtomicPredicate {
	from
		arithmPred : Synthesis!ArithmeticPredicate(arithmPred.oclIsTypeOf(Synthesis!ArithmeticPredicate))
	to 
		atomPred : AMN!AtomicPredicate (
			sign <- arithmPred.symbol,
			expression <- arithmPred.terms
		)
}


