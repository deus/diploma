module Synthesis2AMN;
create OUT:AMN from IN:Synthesis;

-- =============================================================================
-- HELPERS
-- =============================================================================
	
-- =============================================================================
-- RULES
-- =============================================================================
	
rule SynthesisModule2AMNAbstractMachine {
	from
		m : Synthesis!ModuleDef(
			m.oclIsTypeOf(Synthesis!ModuleDef)
			--false
			) 
	to
	    am : AMN!AbstractMachine (
			name <- 'Context' + m.name--,
--			sets <- avalSet, 
--			sets <- oidSet,
--			concreteConstants <- objConst,
--			concreteConstants <- selfConst,
--			concreteConstants <- m.containedTypes->collect(e | thisModule.setConstantsExtpFromADT(e)),
--			concreteConstants <- m.containedTypes->collect(e | thisModule.setConstantsExtFromADT(e)),
--			properties <- propertiesPredicate
		)--,
		
--		avalSet : AMN!Deferred (
--			name <- 'Aval'
--		),
--		oidSet : AMN!Deferred (
--			name <- 'OID'
--		),
--		
--		objConst : AMN!NamedConstant (
--			name <- 'Obj'
--		),
--		selfConst : AMN!NamedConstant (
--			name <- 'self'
--		),		
--		
--		propertiesPredicate : AMN!Conjunction (
--			sign <- '&',
--			predicate <- objProp,
--			predicate <- selfProp,
--			predicate <- equalsPredicate,
--			predicate <- m.containedTypes->collect(e | thisModule.typeConstantsForEachADT(e)),
--			predicate <- conjunction
--		),
--		conjunction : AMN!Conjunction (
--			sign <- 'thisFuckingConjunction'
--		),
--		objProp : AMN!AtomicPredicate (
--			sign <- 'Belongs',
--			expression <- leftObj,
--			expression <- rightAval
--		),
--
--		leftObj : AMN!NamedConstant (
--			name <- 'Obj'
--		),
--		rightAval : AMN!FunctionalExpression (
--			sign <- 'POW',
--			expression <- nameConstAval			
--		),
--		nameConstAval : AMN!NamedConstant (
--			name <- 'AVAL'
--		),
--		selfProp : AMN!AtomicPredicate (
--			sign <- 'Belongs',
--			expression <- leftSelf,
--			expression <- rightObjOID
--		),
--		leftSelf : AMN!NamedConstant (
--			name <- 'self'
--		),
--		rightObjOID : AMN!BinaryOperator (
--			sign <- 'TotalBijection',
--			expression <- leftTotalBijection,
--			expression <- rightTotalBijection			
--		),
--		leftTotalBijection : AMN!NamedConstant (
--			name <- 'Obj'
--		),
--		rightTotalBijection : AMN!NamedConstant (
--			name <- 'OID'
--		),
--		equalsPredicate: AMN!AtomicPredicate (
--			sign <- 'Equals',
--			expression <- intersection,
--			expression <- emptySet
--		),
--		intersection : AMN!BinaryOperator (
--			sign <- 'Intesection',
--			expression <- m.containedTypes->collect(e | thisModule.setConstantsExtpFromADT(e))	
--		),
--		emptySet : AMN!SetValue (
--			value <- emptySetExp			
--		),
--		emptySetExp : AMN!StringValue (
--			value <- 'emptyset'	
--		)
}

lazy rule setConstantsExtpFromADT {
	from
		adt : Synthesis!ADTDef(adt.oclIsTypeOf(Synthesis!ADTDef)) 
	to
		e1 : AMN!NamedConstant (
			name <- 'extp_' + adt.name
		)
}

lazy rule setConstantsExtFromADT {
	from
		adt : Synthesis!ADTDef(adt.oclIsTypeOf(Synthesis!ADTDef)) 
	to
		e2 : AMN!NamedConstant (
			name <- 'ext_' + adt.name
		)
 }

lazy rule typeConstantsForEachADT {
	from
		adt : Synthesis!ADTDef(adt.oclIsTypeOf(Synthesis!ADTDef)) 
	to
		conjunction : AMN!Conjunction (
			sign <- '&',
			predicate <- leftPred,
			predicate <- middlePred,
			predicate <- rightPred
		),
		leftPred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftLeft,
			expression <- rightLeft
		),
		leftLeft : AMN!NamedConstant (
			name <- 'ext_' + adt.name
		),
		rightLeft : AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- objExpLeft
		),
		objExpLeft : AMN!NamedConstant (
			name <- 'Obj'
		),		
		middlePred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftMiddle,
			expression <- rightMiddle
		),
		leftMiddle : AMN!NamedConstant (
			name <- 'extp_' + adt.name
		),
		rightMiddle : AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- objExpMiddle
		),
		objExpMiddle : AMN!NamedConstant (
			name <- 'Obj'
		),
		rightPred : AMN!AtomicPredicate (
			sign <- 'Inclusion',
			expression <- leftRight,
			expression <- rightRight
		),
		leftRight : AMN!NamedConstant (
			name <- 'extp_' + adt.name
		),
		rightRight : AMN!NamedConstant (
			name <- 'ext_' + adt.name
		)
 }

-- Построение конъюнкции тип-подтип и запись ее в контекстную машину модуля
--rule genStrictInclusionFromSubtype(adt : Synthesis!ADTDef, subTypeName : String) {
--	to
--		strictInclusionSubtypeRelation : AMN!AtomicPredicate (
--			sign <- 'Inclusion SUBTYPE',
--			expression <- Sequence{leftExp,rightExp}
--		),
--		leftExp : AMN!NamedConstant (
--			name <- 'ext_' + subTypeName
--		),
--		rightExp : AMN!NamedConstant (
--			name <- 'ext_' + adt.name
--		)
--	do {
--		thisModule.resolveTemp(Synthesis!ModuleDef.allInstances()->any(m|m.oclIsTypeOf(Synthesis!ModuleDef)),'conjunction').predicate<-strictInclusionSubtypeRelation;
--	} 
--}

rule SynthesisADT2AMNAbstractMachine {
	from
		adt : Synthesis!ADTDef(
			adt.oclIsTypeOf(Synthesis!ADTDef)
			--false
		)  
	to
		am : AMN!AbstractMachine (
			name <- adt.name,
			--concreteVariables <- adt.attributes->collect(e | thisModule.attributesToVariables(e)),
			--operations <- adt.attributes->collect(e | thisModule.attributesToOperations(e)),
			--operations <- adt.attributes->select(t | t.type.oclIsTypeOf(Synthesis!FunctionDef))->collect(e | thisModule.functionalattributesToOperations(e)),
			--initialization <- initSubt,
			--invariant <- predicate,
			sees <- thisModule.resolveTemp(Synthesis!ModuleDef.allInstances()->any(m|m.oclIsTypeOf(Synthesis!ModuleDef)), 'am')
			--extendsClause <- adt.supertypes,
		)--,
--		predicate : AMN!Conjunction (
--			sign <- '&',
--			predicate <- adt.attributes->collect(e | thisModule.attributesToInvariants(e))
--		),
--		initSubt : AMN!Simultaneous (
--			substitution <- adt.attributes->collect(e | thisModule.attributesToInitialization(e))
--		)
	do {
-- Вызов построения конъюнкции для отношения тип-подтип
--		if (adt.subtypes->notEmpty()) {
--			for (e in adt.subtypes) {			
--					thisModule.genStrictInclusionFromSubtype(adt,e.name);
--			}
--		}

-- Инклюдится машина, определяющая супертип
		if (adt.supertypes->notEmpty()) {
			for (e in adt.supertypes) {			
					am.includes <- thisModule.resolveTemp(Synthesis!ADTDef.allInstances()->any(m|m.name = e.name), 'am');
			}
		}
	}
}

lazy rule attributesToVariables {
	from
		at : Synthesis!AttributeDef(
			at.oclIsTypeOf(Synthesis!AttributeDef)
			) 
	to
		el : AMN!Variable (
			name <- at.name
 		)
}

lazy rule attributesToInvariants {
	from
		at : Synthesis!AttributeDef(
			at.oclIsTypeOf(Synthesis!AttributeDef)
			) 
	to
		attrPred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftExp,
			expression <- rightExp
		),
		leftExp : AMN!NamedConstant (
			name <- at.name
		),
		rightExp : AMN!BinaryOperator (
			sign <- 'TotalFunction',
			expression <- leftTotalFunction,
			expression <- rightTotalFunction			
		),
		leftTotalFunction : AMN!NamedConstant (
			name <- 'ext_' + at.attributeOf.name			
		),
		rightTotalFunction : AMN!NamedConstant (			
		)
	do {
		if (at.type.oclIsTypeOf(Synthesis!StringDef)) {
			rightTotalFunction.name <- 'String';
		}
		if (at.type.oclIsTypeOf(Synthesis!IntegerDef)) {
		 	rightTotalFunction.name <- 'NAT';
		}
--		if (at.type.oclIsTypeOf(Synthesis!SetDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
--		if (at.type.oclIsTypeOf(Synthesis!EnumDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
	}
}

lazy rule attributesToOperations {
	from
		at : Synthesis!AttributeDef(
			at.oclIsTypeOf(Synthesis!AttributeDef)
			) 
	to
		operation : AMN!Operation (
			name <- 'set' + at.name,
			inputParams <- inpVar,
			substitution <- subst
		),
		inpVar : AMN!Variable (
			name <- 'sav'
		),
		subst : AMN!Precondition (
			pre <- predicate,
			thenPart <- substitution
		),
		predicate : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftExp,
			expression <- rightExp
		),
		leftExp : AMN!NamedConstant (
			name <- 'sav'
		),
		rightExp : AMN!BinaryOperator (
			sign <- 'PartialFunction',
			expression <- leftTotalFunction,
			expression <- rightTotalFunction			
		),
		leftTotalFunction : AMN!NamedConstant (
			name <- 'ext_' + at.attributeOf.name			
		),
		rightTotalFunction : AMN!NamedConstant (			
		),
		substitution : AMN!BecomesEqual (
			leftExpression <- leftExpBecomes,
			rightExpression <- rightExpBecomes
		),
		leftExpBecomes : AMN!NamedConstant (
			name <- at.name			
		),
		rightExpBecomes : AMN!BinaryOperator (
			sign <- 'Overwrite',
			expression <- leftOverwrite,
			expression <- rightOverwrite
		),
		leftOverwrite : AMN!NamedConstant (
			name <- at.name			
		),
		rightOverwrite : AMN!NamedConstant (
			name <- 'sav'			
		)
	do {
		if (at.type.oclIsTypeOf(Synthesis!StringDef)) {
			rightTotalFunction.name <- 'String';
		}
		if (at.type.oclIsTypeOf(Synthesis!IntegerDef)) {
		 	rightTotalFunction.name <- 'NAT';
		}
--		if (at.type.oclIsTypeOf(Synthesis!SetDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
--		if (at.type.oclIsTypeOf(Synthesis!EnumDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
	}		
}

lazy rule attributesToInitialization {
	from
		at : Synthesis!AttributeDef(
			at.oclIsTypeOf(Synthesis!AttributeDef)
			) 
	to
		substitution : AMN!Any (
			any <- setVarName,
			where <- pred,
			thenPart <- subst
		),
		setVarName : AMN!Variable (
			name <- 'a' + at.name
		),
		pred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftExp,
			expression <- rightExp
		),
		leftExp : AMN!NamedConstant (
			name <- 'a' + at.name
		),
		rightExp : AMN!BinaryOperator (
			sign <- 'TotalFunction',
			expression <- leftTotalFunction,
			expression <- rightTotalFunction			
		),
		leftTotalFunction : AMN!NamedConstant (
			name <- 'ext_' + at.attributeOf.name			
		),
		rightTotalFunction : AMN!NamedConstant (			
		),
		subst : AMN!BinaryOperator (
			sign <- 'Overwrite',
			expression <- leftOverwrite,
			expression <- rightOverwrite
		),
		leftOverwrite : AMN!NamedConstant (
			name <- at.name			
		),
		rightOverwrite : AMN!NamedConstant (
			name <- 'a' + at.name			
		)
	do {
		if (at.type.oclIsTypeOf(Synthesis!StringDef)) {
			rightTotalFunction.name <- 'String';
		}
		if (at.type.oclIsTypeOf(Synthesis!IntegerDef)) {
		 	rightTotalFunction.name <- 'NAT';
		}
--		if (at.type.oclIsTypeOf(Synthesis!SetDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
--		if (at.type.oclIsTypeOf(Synthesis!EnumDef)) {			  
--				rightTotalFunction.sign <- 'POW';
--				rightTotalFunction.name <- 'ext_' + at.type;
--				}
	}		
}

rule functionalattributesToOperations {	
	from
		at : Synthesis!AttributeDef(
			at.oclIsTypeOf(Synthesis!AttributeDef) and at.type.oclIsTypeOf(Synthesis!FunctionDef)
			) 
	to
		operation : AMN!Operation (
			name <- 'OPERATION ' + at.name,
			inputParams <- objParam,
			substitution <- subst
		),
		objParam : AMN!Variable (
			name <- 'o'			
		),
		subst : AMN!Precondition (
			pre <- precondPredicate--,
			--thenPart <- thenSubst 
		),
		precondPredicate : AMN!Conjunction ( 
			sign <- '&',
			predicate <- objPred
		),
		objPred : AMN!AtomicPredicate (
			sign <- 'Belongs',
			expression <- leftAtomic,
			expression <- rightAtomic
		),
		leftAtomic : AMN!Variable (
			name <- 'o'
		),
		rightAtomic : AMN!NamedConstant (
			name <- 'ext' + at.attributeOf.name
		)
	do {
		for ( e in at.type.parameters ) {
			thisModule.generateParameters(e, at);
		}
		thisModule.resolveTemp(Synthesis!ADTDef.allInstances()->any(m | m.name = at.attributeOf.name),'am').operations<-operation;
	}
}

rule generateParameters ( param : Synthesis!ParameterDef, attr : Synthesis!AttributeDef ) {
	to 
		var : AMN!Variable (
			name <- param.name			
		),
		varPred : AMN!AtomicPredicate (
			sign <- 'Belongs to Datatype In operation',
			expression <- var,
			expression <- rightAtomic
		),
		rightAtomic : AMN!NamedConstant (
			name <- param.type.name
		)
	do {
		if ( param.parameterKind = 'input' ) {
			thisModule.resolveTemp(Synthesis!AttributeDef.allInstances()->
									any(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
												then if m.name = attr.name 
														then true
														else false
														endif
												else false
											endif),'operation').inputParams<-var;
		}
		else {
			if ( param.parameterKind = 'output' ) {
				thisModule.resolveTemp(Synthesis!AttributeDef.allInstances()->
									any(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
												then if m.name = attr.name 
														then true
														else false
														endif
												else false
											endif),'operation').outputParams<-var;
			}
		}
		thisModule.resolveTemp(Synthesis!AttributeDef.allInstances()->
									any(m | if m.type.oclIsTypeOf(Synthesis!FunctionDef)
												then if m.name = attr.name 
														then true
														else false
														endif
												else false
											endif),'precondPredicate').predicate<-varPred;
	}
}




